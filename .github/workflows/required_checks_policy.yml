# Policy format:
# [
#   {
#     "checks": ["check1", "check2"],
#     "paths": ["service1/"]
#   },
#   {
#     "checks": ["check1"],
#     "paths": ["service2/"]
#   },
# ]
on:
    workflow_call:
        inputs:
            policyPath:
                required: true
                type: string
                description: The path to the policy file. It is relative to the root of the git repository.
            failIfNoPolicy:
                required: false
                type: boolean
                default: true
                description: |
                  If set to `true`, the workflow will fail if no policy is defined for the changed files.
                  If set to `false`, the workflow will succeed if no policy is defined, but will not check for required checks.
            timeout-minutes:
                required: false
                description: The maximum number of minutes to let a workflow run before GitHub automatically cancels it.
                type: number
                default: 360 # Same value as the default for GitHub Actions
            timeout-minutes-queued-checks:
                required: false
                description: |
                  Specifies how many minutes required checks can remain in the queued state before the workflow is canceled.
                  If checks do not start within this time, the workflow will fail, which may indicate a configuration problem.
                type: number
                default: 30
            timeout-minutes-created-checks:
                required: false
                description: |
                  The maximum number of minutes to let a check be created before canceling the workflow.
                  If checks is not created within this time, the workflow will fail, which may indicate a configuration problem.
                type: number
                default: 15

jobs:
    evaluate_policy:
        runs-on: ubuntu-latest
        timeout-minutes: ${{ inputs.timeout-minutes }}
        steps:
            - uses: actions/checkout@v5
              with:
                fetch-depth: 0
            - name: Evaluate required checks policy
              shell: pwsh
              env:
                CI_POLICY_PATH: ${{ inputs.policyPath }}
                CI_FAIL_IF_NO_POLICY: ${{ inputs.failIfNoPolicy }}
                CI_TIMEOUT_MINUTES_QUEUED_CHECKS: ${{ inputs.timeout-minutes-queued-checks }}
                CI_TIMEOUT_MINUTES_CREATED_CHECKS: ${{ inputs.timeout-minutes-created-checks }}
                REPOSITORY_DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
                GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                $ErrorActionPreference = "Stop"
                $PSNativeCommandUseErrorActionPreference = $true

                # Find base/head refs to compare
                $CommitId = $env:GITHUB_SHA
                $BaseRef = $env:GITHUB_BASE_REF
                $HeadRef = $env:GITHUB_HEAD_REF
                if (!$HeadRef) {
                    $HeadRef = $env:GITHUB_REF_NAME
                }

                if (!$BaseRef) {
                    Write-Host "Base ref is not set. Falling back to default branch '$env:REPOSITORY_DEFAULT_BRANCH'."
                    $BaseRef = $env:REPOSITORY_DEFAULT_BRANCH
                }

                Write-Host "Change description:"
                Write-Host "Commit ID: $CommitId"
                Write-Host "Base Ref: $BaseRef"
                Write-Host "Head Ref: $HeadRef"
                Write-Host ""


                # Load policy from target branch
                $policyPath = $env:CI_POLICY_PATH
                if ($policyPath) {
                    # Load the policy from the target branch, so a user cannot change the policy in the PR branch
                    Write-Host "Loading policy at '$policyPath' in ref '$BaseRef'"
                    try {
                        $policyContent = git show "${FullBaseRef}:$policyPath" 2>$null
                    } catch {
                        # List available git refs and files for debug purposes
                        # Note that some repositories have a lot of files (10_000s), so this may produce a lot of output
                        # We do it only in case of error to avoid cluttering the logs in success runs
                        Write-Host "::group::Available git references"
                        git show-ref
                        Write-Host "::endgroup::"

                        $FullBaseRef = "refs/remotes/origin/$BaseRef"
                        Write-Host "::group::Available files in $FullBaseRef"
                        git ls-tree --full-tree -r --name-only "$FullBaseRef"
                        Write-Host "::endgroup::"

                        Write-Error "❌ Failed to load policy file from '$BaseRef' branch at '$policyPath'. Make sure the file exists in the target branch and that the path is relative to the root of the repository."
                    }

                    $policy = $policyContent | ConvertFrom-Json
                }

                if (-not $policy) {
                    Write-Error "❌ Policy is not defined or is empty."
                    exit 1
                }

                Write-Host "::group::Policy details"
                Write-Host ($policy | ConvertTo-Json -Depth 10)
                Write-Host "::endgroup::"

                # List changed files between base and head refs for debugging purpose
                $diff = (git diff --name-only "refs/remotes/origin/$BaseRef...refs/remotes/origin/$HeadRef") | Where-Object { $_ }
                if (!$diff) {
                    Write-Host "✅ No changes detected between '$BaseRef' and '$HeadRef'."
                    exit 0
                }

                Write-Host "::group::Changed files between '$BaseRef' and '$HeadRef'"
                $diff | ForEach-Object {
                    Write-Host "- $_"
                }

                Write-Host "::endgroup::"
                Write-Host ""

                # Find required checks for changed files
                $requiredChecks = @()
                foreach ($item in $policy) {
                    $checks = $item.checks
                    $paths = $item.paths

                    # Validate paths
                    $pathspecs = @()
                    foreach ($path in $paths) {
                        if (-not $path) {
                            continue
                        }

                        # Git pathspec magic signatures support exclusions with :(exclude) prefix
                        # Paths starting with ! are exclusions
                        if ($path.StartsWith("!")) {
                            Write-Error "❌ Path exclusions starting with '!' are not supported in the policy. Please use ':(exclude)<path>' syntax instead (https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-pathspec). Invalid path: '$path'"
                            exit 1
                        }

                        $pathspecs += $path
                    }

                    if ($pathspecs.Count -eq 0) {
                        Write-Debug "⚠️ No valid paths found in policy item. Skipping."
                        continue
                    }

                    # Pass all pathspecs at once to git diff to properly handle inclusions and exclusions
                    $gitArgs = @("diff", "--name-only", "refs/remotes/origin/$BaseRef...refs/remotes/origin/$HeadRef", "--")
                    $gitArgs += $pathspecs

                    $diff = (& git @gitArgs) | Where-Object { $_ }
                    if ($diff) {
                        Write-Debug "Paths '$($paths -join "', '")' have changes. Adding required checks: $($checks -join ', ')"
                        foreach ($check in $checks) {
                            $requiredChecks += $check
                        }
                    }
                }

                if ($requiredChecks.Count -eq 0) {
                    if ($env:CI_FAIL_IF_NO_POLICY -eq 'true') {
                        Write-Error "❌ No required checks found for the changed paths, but 'failIfNoPolicy' is set to true."
                        exit 1
                    }

                    Write-Host "✅ No required checks found for the changed paths."
                    exit 0
                }

                $requiredChecks = $requiredChecks | Sort-Object -Unique
                Write-Host "Required checks for changed paths:"
                $requiredChecks | ForEach-Object {
                    Write-Host "- $_"
                }

                Write-Host ""

                Write-Host "Waiting for required checks to complete..."
                # https://docs.github.com/en/rest/checks/runs?apiVersion=2022-11-28#list-check-runs-for-a-git-reference
                $url = "repos/$env:GITHUB_REPOSITORY/commits/$HeadRef/check-runs?filter=latest&per_page=100"
                Write-Debug "API URL: $url"

                $attempt = 0;

                # TODO support CI_TIMEOUT_MINUTES_TO_START_CHECKS
                $TimeoutCreated = New-TimeSpan -Minutes $env:CI_TIMEOUT_MINUTES_CREATED_CHECKS
                $TimeoutQueued = New-TimeSpan -Minutes $env:CI_TIMEOUT_MINUTES_QUEUED_CHECKS
                $startedAt = Get-Date -AsUTC
                $CompletedCheckNames = @()

                # Implementation note: Be sure to always print the check runs response at least once to help debugging issues
                while ($true) {
                    try {
                        # --slurp is required with --paginate to combine all pages into a single JSON array
                        # The response is an array of page objects, each containing a check_runs property
                        $rawResponse = gh api --paginate --slurp $url
                        $pages = $rawResponse | ConvertFrom-Json

                        # Flatten all check_runs from all pages into a single array
                        $allCheckRuns = @()
                        foreach ($page in $pages) {
                            if ($page.check_runs) {
                                $allCheckRuns += $page.check_runs
                            }
                        }

                        # Create a single response object matching the original API structure
                        $checkRuns = [PSCustomObject]@{
                            check_runs = $allCheckRuns
                            total_count = $allCheckRuns.Count
                        }
                    }
                    catch {
                        Write-Error "❌ Failed to call GitHub API. Raw response: $rawResponse"
                        Write-Error "Error details: $_"
                        throw
                    }

                    Write-Host "::debug::Check runs response ($url): $($checkRuns | ConvertTo-Json -Compress -Depth 10)"

                    $completed = $true
                    $NewlyCompletedChecks = @()
                    foreach ($requiredCheck in $requiredChecks) {
                        $check = $checkRuns.check_runs | Where-Object { $_.name -eq $requiredCheck }

                        # Not supported yet: Handle case where there are multiple checks with the same name (e.g. push / pull_request)
                        # Check how GitHub handles this case when using required checks in branch protection rules
                        if ($check.Count -gt 1) {
                            Write-Host "::group::Response for $url"
                            Write-Host "$($checkRuns | ConvertTo-Json -Compress -Depth 10)"
                            Write-Host "::endgroup::"
                            Write-Host "❌ Multiple checks found with name '$requiredCheck'. This is not supported yet. Please report an issue if you encounter this."
                            exit 1
                        }

                        if ($check) {
                            if ($check.status -eq "completed") {
                                if ($check.conclusion -ne "success") {
                                    Write-Host "::group::Response for $url"
                                    Write-Host "$($checkRuns | ConvertTo-Json -Compress -Depth 10)"
                                    Write-Host "::endgroup::"
                                    Write-Error "❌ Check '$requiredCheck' failed with conclusion: $($check.conclusion). Details: $($check.html_url)"
                                    exit 1
                                }
                                else {
                                    # Track if this is a newly completed check
                                    if ($CompletedCheckNames -notcontains $requiredCheck) {
                                        $NewlyCompletedChecks += [PSCustomObject]@{
                                            Name = $requiredCheck
                                            Url = $check.html_url
                                        }

                                        $CompletedCheckNames += $requiredCheck
                                    }
                                }
                            }
                            elseif ($check.status -eq "queued") {
                                $completed = $false
                                if ((Get-Date -AsUTC) - $startedAt -gt $TimeoutQueued) {
                                    Write-Host "::group::Response for $url"
                                    Write-Host "$($checkRuns | ConvertTo-Json -Compress -Depth 10)"
                                    Write-Host "::endgroup::"
                                    Write-Error "❌ Check '$requiredCheck' is still queued after $($TimeoutQueued.TotalMinutes) minutes (timeout-minutes-queued-checks: $($env:CI_TIMEOUT_MINUTES_QUEUED_CHECKS)). Details: $($check.html_url)"
                                    exit 1
                                }
                            }
                            else {
                                # Check is in progress or another state, keep waiting
                                $completed = $false
                                Write-Debug "Check '$requiredCheck' is in status '$($check.status)'. Waiting..."
                            }
                        }
                        else {
                            $completed = $false
                            if ((Get-Date -AsUTC) - $startedAt -gt $TimeoutCreated) {
                                $checkNames = $checkRuns.check_runs | ForEach-Object { "- $($_.name)" } | Sort-Object -Unique

                                Write-Host "::group::Response for $url"
                                Write-Host "$($checkRuns | ConvertTo-Json -Compress -Depth 10)"
                                Write-Host "::endgroup::"
                                Write-Error "❌ Check '$requiredCheck' wasn't created after $($TimeoutCreated.TotalMinutes) minutes (timeout-minutes-created-checks: $($env:CI_TIMEOUT_MINUTES_CREATED_CHECKS)). Available checks:`n$($checkNames -join "`n")"
                                exit 1
                            }
                        }
                    }

                    # Log newly completed checks
                    if ($NewlyCompletedChecks.Count -gt 0) {
                        foreach ($completedCheck in $NewlyCompletedChecks) {
                            Write-Host "✅ Check '$($completedCheck.Name)' completed successfully. Details: $($completedCheck.Url)"
                        }
                    }

                    if ($completed) {
                        Write-Host "::group::Response for $url"
                        Write-Host "$($checkRuns | ConvertTo-Json -Compress -Depth 10)"
                        Write-Host "::endgroup::"
                        Write-Host "✅ All required checks have passed."
                        exit 0
                    }

                    $attempt += 1
                    $WaitTime = 10 * $attempt
                    if ($WaitTime -gt 60) {
                        $WaitTime = 60
                    }

                    $InfoLog = ""
                    if ($CompletedCheckNames.Count -gt 0) {
                        $InfoLog += "Completed checks: $(($CompletedCheckNames | Sort-Object) -join ', ')."
                    }
                    else {
                        $InfoLog += "No checks completed yet."
                    }

                    Write-Host "$InfoLog Waiting for $WaitTime seconds before checking again..."
                    Start-Sleep -Seconds $WaitTime
                }
