name: 'Sync Template to Downstream Repos'

on:
  workflow_call:
    inputs:
      templateRepoName:
        description: 'Name of the template repository'
        type: string
        required: true
      repoPrefix:
        description: 'Prefix for downstream repositories'
        type: string
        required: true
      workflowFileName:
        description: 'Name of the sync workflow file to not copy. Defaults to update-downstreams.yml'
        type: string
        default: 'update-downstreams.yml'
      filesToSync:
        description: 'Space-separated list of files and folders to sync from the template'
        type: string
        default: 'CONTRIBUTING.md SECURITY.md renovate.json .github/'
        required: false
      ignoreRepos:
        description: 'Comma-separated list of repository names to ignore during sync'
        type: string
        default: ''
        required: false
      rateLimitThreshold:
        description: 'Rate limit threshold for GitHub API calls'
        type: number
        default: 10
        required: false

permissions:
  pull-requests: write
  contents: read
  repository-projects: read

jobs:
  get-repos:
    runs-on: [idp]
    outputs:
      repos: ${{ steps.get-repos.outputs.repos }}
    steps:
      - name: Authenticate with GitHub App
        id: auth
        uses: actions/create-github-app-token@v2
        with:
          owner: workleap
          app-id: ${{ secrets.TERRAFORM_AUTOMATION_APP_ID }}
          private-key: ${{ secrets.TERRAFORM_AUTOMATION_PRIVATE_KEY }}
      - name: Get repositories with prefix
        id: get-repos
        shell: pwsh
        run: |
          function Wait-For-GitHub-RateLimit {
            $rateInfo = gh api rate_limit --jq '[.resources.core.remaining, .resources.core.reset]' | ConvertFrom-Json
            if ([int]$rateInfo[0] -lt ${{ inputs.rateLimitThreshold }}) {
              $wait = (Get-Date -UnixTimeSeconds $rateInfo[1]) - (Get-Date)
              if ($wait -lt [TimeSpan]::Zero) {
                $wait = [TimeSpan]::Zero
              }
              Write-Host ("GitHub rate limit low, sleeping for {0:N0} seconds until reset..." -f $wait.TotalSeconds)
              if ($wait -gt [TimeSpan]::Zero) {
                Start-Sleep -Duration $wait
              }
            }
          }

          Wait-For-GitHub-RateLimit
          # List all repos via the installation repository endpoint using the App token
          $allRepos = gh api /installation/repositories --paginate --jq '.repositories[].name'
          $ignoreList = "${{ inputs.ignoreRepos }}".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
          $filteredRepos = @()
          # Filter by prefix, exclude template repo and ignored repos
          foreach ($name in $allRepos) {
            if ($name -like "${{ inputs.repoPrefix }}*" -and $name -ne "${{ inputs.templateRepoName }}" -and $name -notin $ignoreList) {
              $filteredRepos += $name
            }
          }
          $reposJson = ConvertTo-Json @($filteredRepos) -Compress
          Add-Content -Path $env:GITHUB_OUTPUT -Value "repos=$reposJson"

          Write-Host "Number of repositories matching query found: " $filteredRepos.Count
        env:
          GH_TOKEN: ${{ steps.auth.outputs.token }}

  sync:
    needs: get-repos
    runs-on: [idp]
    strategy:
      matrix:
        repo: ${{ fromJson(needs.get-repos.outputs.repos) }}
      max-parallel: 3
      fail-fast: false
    steps:
      - name: Authenticate with GitHub App
        id: auth
        uses: actions/create-github-app-token@v2
        with:
          owner: workleap
          app-id: ${{ secrets.TERRAFORM_AUTOMATION_APP_ID }}
          private-key: ${{ secrets.TERRAFORM_AUTOMATION_PRIVATE_KEY }}

      - name: Checkout Template
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
          path: template

      - name: Checkout Downstream
        uses: actions/checkout@v5
        with:
          repository: workleap/${{ matrix.repo }}
          token: ${{ steps.auth.outputs.token }}
          path: downstream
          fetch-depth: 0

      - name: Set git author
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Merge Template Changes
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          function Assert-ExitCode {
            param([string]$Command)
            if ($LASTEXITCODE -ne 0) {
              throw "$Command failed with exit code $LASTEXITCODE"
            }
          }

          function Wait-For-GitHub-RateLimit {
            $rateInfo = gh api rate_limit --jq '[.resources.core.remaining, .resources.core.reset]' | ConvertFrom-Json
            if ([int]$rateInfo[0] -lt ${{ inputs.rateLimitThreshold }}) {
              $wait = (Get-Date -UnixTimeSeconds $rateInfo[1]) - (Get-Date)
              Write-Host "GitHub rate limit low, sleeping for $wait seconds until reset..."
              Start-Sleep -Duration $wait
            }
          }

          # Move into the downstream clone
          Set-Location downstream

          # Add and fetch the template remote
          git remote add template ../template
          Assert-ExitCode 'git remote add'
          git fetch --no-tags template
          Assert-ExitCode 'git fetch template'

          $excludePattern = ":(exclude).github/workflows/${{ inputs.workflowFileName }}"

          # Parse and validate filesToSync to avoid git option/pathspec injection
          $rawFilesToSync = '${{ inputs.filesToSync }}'
          $filesToSync = $rawFilesToSync -split '\s+' | Where-Object { $_ -ne '' }
          foreach ($path in $filesToSync) {
            if ($path.StartsWith('-')) {
              throw "Invalid entry in filesToSync (looks like a git option): $path"
            }
          }

          # Build git restore arguments, using '--' so remaining tokens are treated as pathspecs
          $gitRestoreArgs = @(
            '--source=template/main'
            '--staged'
            '--worktree'
            '--'
          )
          $gitRestoreArgs += $filesToSync
          $gitRestoreArgs += $excludePattern

          git restore @gitRestoreArgs
          Assert-ExitCode 'git restore'
          # Remove the sync workflow file to avoid conflicts
          git rm --ignore-unmatch .github/workflows/${{ inputs.workflowFileName }}
          $staged = git diff --cached --name-only

          if ($staged) {
            $maxRetries = 5
            $prSleepSeconds = 10
            $maxChecks = 10
            $mergeSleepSeconds = 15

            # Fetch latest main and create sync branch
            git fetch origin main
            Assert-ExitCode 'git fetch origin'
            git switch -c sync-template origin/main
            Assert-ExitCode 'git switch'

            # Commit staged template changes
            git commit -m "Sync template files from ${{ inputs.templateRepoName }}"
            Assert-ExitCode 'git commit'

            # Push changes, force update existing branch if needed
            git push -u origin sync-template --force-with-lease
            Assert-ExitCode 'git push'

            for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
                Write-Host "Creating PR (attempt $attempt of $maxRetries)..."
                try {
                    Wait-For-GitHub-RateLimit
                    gh pr create `
                      --repo workleap/${{ matrix.repo }} `
                      --base main `
                      --head sync-template `
                      --title "Sync template files from ${{ inputs.templateRepoName }}" `
                      --body "Automated sync of template files from ${{ inputs.templateRepoName }}."
                    Write-Host "PR created successfully."
                    break
                } catch {
                    Write-Warning "PR creation failed (try $attempt): $_"
                    if ($attempt -lt $maxRetries) {
                        Write-Host "Sleeping for $prSleepSeconds seconds before retry..."
                        Start-Sleep -Seconds $prSleepSeconds
                        $prSleepSeconds = [math]::Min($prSleepSeconds * 2, 60)
                    } else {
                        throw "Failed to create PR after $maxRetries attempts."
                    }
                }
            }

            for ($i = 1; $i -le $maxChecks; $i++) {
              Write-Host "Checking mergeable status (attempt $i of $maxChecks)..."

              $mergeableState = gh pr view sync-template `
                                --repo workleap/${{ matrix.repo }} `
                                --json mergeable `
                                --jq '.mergeable'
              Write-Host "Mergeable status: $mergeableState"

              if ($mergeableState -eq 'MERGEABLE') {
                Wait-For-GitHub-RateLimit
                gh pr merge sync-template `
                  --repo workleap/${{ matrix.repo }} `
                  --admin `
                  --squash `
                  --delete-branch
                Write-Host "PR merged and branch deleted."
                break
              } elseif ($mergeableState -eq 'UNMERGEABLE') {
                throw "PR is unmergeable. Aborting sync."
              } else {
                if ($i -lt $maxChecks) {
                  Write-Host "Mergeable status unknown. Waiting $mergeSleepSeconds seconds..."
                  Start-Sleep -Seconds $mergeSleepSeconds
                  $mergeSleepSeconds = [math]::Min($mergeSleepSeconds * 2, 60)
                } else {
                  throw "PR did not become mergeable after $maxChecks checks."
                }
              }
            }

          } else {
            Write-Output "No changes to commit"
          }

        env:
          GH_TOKEN: ${{ steps.auth.outputs.token }}
